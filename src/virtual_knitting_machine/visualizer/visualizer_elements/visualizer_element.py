"""Module containing the Visualizer Element class and common primitive subclasses."""

from __future__ import annotations

from enum import Enum
from typing import Any

from svgwrite import Drawing
from svgwrite.base import BaseElement
from svgwrite.text import Text


class Visualizer_Element:
    """Super class for all visualizer element wrappers that support coordinate checking and transformation.

    Attributes:
        parent (Visualizer_Element | None): The optional parent element of this element used to find global coordinate position.
    """

    def __init__(self, x: float, y: float, name: str, **element_kwargs: Any):
        self._svg_element: BaseElement | None = None
        self._x: float = x
        self._y: float = y
        self._name: str = name
        self.parent: Visualizer_Element | None = None
        self._element_kwargs: dict[str, Any] = element_kwargs

    @property
    def name(self) -> str:
        """
        Returns:
            str: The unique name of this element. This will match the id of the svg element being wrapped.
        """
        return self._name

    @property
    def x(self) -> float:
        """
        Returns:
            float: The x coordinate of this element relative to its parent (or globally).
        """
        return self._x

    @property
    def y(self) -> float:
        """
        Returns:
            float: The y coordinate of this element relative to its parent (or globally).
        """
        return self._y

    @property
    def global_x(self) -> float:
        """
        Returns:
            float: The global x coordinate of this element based on its parent's coordinates.
        """
        if self.parent is None:
            return self.x
        else:
            return self.parent.global_x + self.x

    @property
    def global_y(self) -> float:
        """
        Returns:
            float: The global y coordinate of this element based on its parent's coordinates.
        """
        if self.parent is None:
            return self.y
        else:
            return self.parent.global_y + self.y

    def global_x_position(self, x: float) -> float:
        """
        Args:
            x (float): An X-coordinate position relative to this element's coordinate system.

        Returns:
            float: The x-coordinate adjusted to the global coordinate system.
        """
        return self.global_x + x

    def global_y_position(self, y: float) -> float:
        """
        Args:
            y (float): An Y-coordinate position relative to this element's coordinate system.

        Returns:
            float: The y-coordinate adjusted to the global coordinate system.
        """
        return self.global_y + y

    def _build_svg_element(self) -> BaseElement:
        """
        Generates the SVG element generated by this wrapper class.

        Returns:
            BaseElement: The generated SVG element for this wrapper class.
        """
        raise NotImplementedError("Implement in base class")

    def add_to_drawing(self, drawing: Drawing) -> None:
        """
        Adds this element to the given svg drawing.
        Args:
            drawing (Drawing): The drawing to add.
        """
        drawing.add(self._build_svg_element())

    def __str__(self) -> str:
        return self.name

    def __repr__(self) -> str:
        return str(self)

    def __hash__(self) -> int:
        return hash(self.name)

    @staticmethod
    def fill_from_stroke(stroke: str, lighten_factor: float = 0.3) -> str:
        """
        Args:
            stroke (str): The color string of the stroke to be lightened for infill.
            lighten_factor (float, optional): The factor to lighten the stroke color by. Defaults to 0.3.

        Returns:
            str: The fill color string created by lightening the stroke color.
        """
        return Visualizer_Element.lighten_color(stroke, lighten_factor)

    @staticmethod
    def stroke_from_fill(fill: str, darken_factor: float = 0.7) -> str:
        """

        Args:
            fill (str): The color string of the fill to be darkened for an outline.
            darken_factor (float, optional): The factor to darken the fill color by. Defaults to 0.7.

        Returns:
            str: The stroke color string created by darkening the fill color.
        """
        return Visualizer_Element.darken_color(fill, darken_factor)

    @staticmethod
    def darken_color(color: str = "none", factor: float = 0.7) -> str:
        """Darken a hex or named color.
        Args:
            color (str): The color to darken. Either a named color or a hex representation of the color.
            factor (float, optional):
                A factor to darken. Defaults to 0.7.
                * 0.0 = No change.
                * 1.0 = black.

        Returns:
            str: The color-string of the darkened color. If "none" color is given, this will return "black".
        """
        if color == "none":
            return "black"
        elif not color.startswith("#"):  # Handle named colors
            try:
                import webcolors

                color = webcolors.name_to_hex(color)
            except (ImportError, ValueError):
                # Fallback: assume it's already valid
                pass

        # Rest of your darkening code...
        color = color.lstrip("#")
        r = int(int(color[0:2], 16) * factor)
        g = int(int(color[2:4], 16) * factor)
        b = int(int(color[4:6], 16) * factor)
        return f"#{r:02x}{g:02x}{b:02x}"

    @staticmethod
    def lighten_color(color: str = "none", factor: float = 0.3) -> str:
        """Lighten a hex or named color.

        Args:
            color (str, optional): The color to lighten. Either a named color or a hex representation of the color. Defaults to transparent ("none").
            factor (float, optional):
                A factor to lighten (0.0 to 1.0). Defaults to 0.3.
                * 0.0 = no change.
                * 1.0 = white.
        Returns:
            str: The color-string of the lightened color. If "none" color is given, this will return "black".
        """
        if color == "none":
            return "black"
        elif not color.startswith("#"):  # Handle named colors
            try:
                import webcolors

                color = webcolors.name_to_hex(color)
            except (ImportError, ValueError):
                # Fallback: assume it's already valid
                pass

        # Parse the color
        color = color.lstrip("#")
        r = int(color[0:2], 16)
        g = int(color[2:4], 16)
        b = int(color[4:6], 16)

        # Lighten by moving each component toward 255 (white)
        r = int(r + (255 - r) * factor)
        g = int(g + (255 - g) * factor)
        b = int(b + (255 - b) * factor)

        # Clamp to valid range
        r = min(255, r)
        g = min(255, g)
        b = min(255, b)

        return f"#{r:02x}{g:02x}{b:02x}"


class Text_Anchor(Enum):
    """Enumeration of Text Anchoring options for text elements"""

    start = "start"  # Text will render leftward from its x coordinate.
    middle = "middle"  # Text will render centered on its x coordinate
    end = "end"  # Text will render up to its x coordinate

    def __str__(self) -> str:
        return str(self.value)


class Text_Baseline(Enum):
    """Enumeration of Text Anchoring options for text elements"""

    baseline = "baseline"  # Text will render upward from its y coordinate.
    middle = "middle"  # Text will render centered on its y coordinate
    hanging = "hanging"  # Text will render downward from its y coordinate

    def __str__(self) -> str:
        return str(self.value)


class Text_Element(Visualizer_Element):
    """
    Wrapper class for Text SVG elements.
    """

    def __init__(
        self,
        x: float,
        y: float,
        label: str,
        name: str | None = None,
        font_family: str = "Arial",
        font_size: int = 14,
        is_bold: bool = False,
        is_italic: bool = False,
        text_anchor: Text_Anchor = Text_Anchor.middle,
        alignment_baseline: Text_Baseline = Text_Baseline.middle,
        font_color: str = "black",
        **element_kwargs: Any,
    ) -> None:
        """
        Initialize the text element.
        Args:
            x (float): The x coordinate of this element relative to its parent (or globally).
            y (float): The y coordinate of this element relative to its parent (or globally).
            label (str): The value of the text label.
            name (str, optional): The id name of this element defaults to "label_<label>".
            font_family (str, optional): The font family to render the text in. Defaults to "Arial".
            font_size (int, optional): The font size to render the text in. Defaults to 14px height.
            is_bold (bool, optional): Whether the text is bold. Defaults to False.
            is_italic (bool, optional): Whether the text is italic. Defaults to False.
            text_anchor (str, optional): The anchor to render the text in. Defaults to "middle".
            **element_kwargs (Any): Keyword arguments used to configure the svg text element.
        """
        super().__init__(x, y, name if name is not None else f"label_{label}", **element_kwargs)
        self.label: str = label
        self.font_family: str = font_family
        self.font_size: int = font_size
        self.font_weight: str = "bold" if is_bold else "normal"
        self.font_style: str = "italic" if is_italic else "normal"
        self.text_anchor: Text_Anchor = text_anchor
        self.alignment_baseline: Text_Baseline = alignment_baseline
        self.font_color: str = font_color

    @property
    def approximate_label_width(self) -> float:
        """
        Returns:
            float: The approximate width of the text label.

        Notes:
            Very rough estimate: ~0.6 * font_size per character for typical fonts.
        """
        return len(self) * self.font_size * 0.6

    @staticmethod
    def approximate_text_width(char_count: int, font_size: int = 14) -> float:
        """
        Args:
            char_count (int): The total number of characters.
            font_size (int, optional): The font size in pixels. Defaults to 14.

        Returns:
            float: The approximate width of the text based on the number of characters.

        Notes:
            Very rough estimate: ~0.6 * font_size per character for typical fonts.
        """
        return char_count * font_size * 0.6

    def _build_svg_element(self) -> Text:
        return Text(
            self.label,
            insert=(self.global_x, self.global_y),
            id=self.name,
            font_family=self.font_family,
            font_size=self.font_size,
            font_weight=self.font_weight,
            font_style=self.font_style,
            text_anchor=str(self.text_anchor),
            alignment_baseline=str(self.alignment_baseline),
            fill=self.font_color,
            **self._element_kwargs,
        )

    def __len__(self) -> int:
        """
        Returns:
            int: The number of characters in the label.
        """
        return len(self.label)
